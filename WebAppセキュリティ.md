# Webアプリケーションセキュリティ

### 入力値の文字エンコーディングp118
・入力値検証はアプリケーション仕様に基づいて行う
・文字エンコーディングの検証
・制御文字を含む文字種の検証
・文字数の検証
・数値の最小・最大値の検証

実施は以下の手順で行う
・設計段階で各パラメータの文字種および最大文字数、最小値・最大値を仕様として決める
・設計段階で入力値検証の実装方針を決める
・開発段階では仕様に従い入力値検証を実装

### XSS対策の基本
HTMLのinputに対し、
・「＜」と「＆」をエスケープする
・属性値については、ダブルクォートで囲って、「＜」と「"」と「＆」をエスケープする
phpでは、htmlのエスケープ処理にはhtmlspecialchars関数がある

### XSSに対する保険的対策p136
#### X-XSS-Protectionの使用
ブラウザのXSSフィルタというセキュリティ機能を有効にする。
Apacheの設定例(mod_headersが必要)
```bash
Header always append X-XSS-Protection: 1; mode=block
```

#### クッキーにHttpOnly属性を付与する
JavaScriptからのクッキー読み出しを禁止する
PHPの場合、php.iniに設定を追加

```php
session.cookie_httponly = on
```

## まとめ
**必須対策(個別の対策)**

- HTMLの要素内容 htmlspecialchars関数によりエスケープ
- 属性値 htmlspecialchars関数によりエスケープしてダブルクォートで囲む

**必須対策(共通対策)**

- HTTPレスポンスに文字エンコーディングを明示する

**保険的対策**

- X-XSS-Protection レスポンスヘッダの使用
- 入力値検証
- クッキーにHttpOnly属性を付与
- TRACEメソッドの無効化

### URLを生成する場合の対策
URLをプログラムで生成する場合、httpとhttpsスキームのみを許可するようにチェックする必要がある。また、通ったURLは属性値としてHTMLエスケープする必要がある。
- http: または https: で始まる絶対URL
- スラッシュ「/」で始まる相対URL(絶対パス参照)

これをPHPでチェックする関数の実装例

```js
function check_url($url) {
  if (preg_match('/\Ahttps?:/', $url) || preg_match('/\A\//', $url)) {
    return true;
  } else {
    return false;
  }
}
```

引数で与えた文字列が「http:」あるいは「https:」あるいは「/」で始まっているかをtrue falseで判定

### JavaScriptの文字列リテラルの動的生成の対策
#### script要素の外部でパラメータを定義して、JavaScriptから参照する方法
カスタムデータ属性を利用して、通常のHTMLエスケープによりXSS対策が可能になる。
```html
<!DOCTYPE html>
<html lang="ja" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>
    <!--phpからクエリ―文字列を受け取り、nameに格納して出力。
    それをカスタムデータ属性のdata-nameに渡す-->
    <div id="name" data-name="<?php echo htmlspecialchars($_GET['name'], ENT_COMPAT, 'UTF-8'); ?>"></div>
    <script>
    const div = document.getElementById('name');
    const txt = div.dataset.name;
    div.textContent = `${txt}の文字数は${txt.length}文字です`;
    </script>
  </body>
</html>
```

## CSRFについてp175
### CSRF攻撃と反射型XSS攻撃の比較
・罠サイト
  ↑①閲覧 ↓②仕掛けのあるHTML
・利用者(HTMLの改変,スクリプト実行(XSS))
  ↓③攻撃用リクエスト ↑④仕掛けを含むレスポンス
・正規サイト(不正操作(CSRF))

#### CSRF
③のリクエストに対するサーバー側の処理を悪用するもの。悪用内容は、もともとサーバー側で用意された処理に限定。
#### XSS
③のリクエストに含まれるスクリプトはオウム返しに④のレスポンスとして返され、それがブラウザ上で実行されることで攻撃が起きる。ブラウザ上では、攻撃者が用意したHTMLやJavaScriptが実行できるため、ブラウザ上でできることはなんでも悪用可能。

### 脆弱性が生まれる原因
CSRF脆弱性が生まれる背景としては以下のWebの性質がある
（１）form要素のaction属性にはどのドメインのURLでも指定できる。
（２）クッキーに保管されたセッションIDは、対象サイトに自動的に送信される

### 対策
以下の2点を実施
（１）CSRF対策の必要なページを区別する
（２）正規利用者の意図したリクエストを確認できるよう実装する

#### CSRF対策の必要なページを区別
- 要件定義工程で機能一覧を作成し、CSRF対策の必要な機能にマーク
- 基本設計工程で画面推移図を作成し、CSRF対策の必要なページにマークする
- 開発工程でCSRF対策を作り込む

#### 正規利用者の意図したリクエストであることを確認する
- **秘密情報(トークン)の埋め込み**
第三者が知り得ない情報を要求する
最近はアプリケーションフレームワーク側でトークンの生成とチェックの機能を持つものがある。
→このやり方が最も一般的で、あらゆる場面で利用を推奨されている。

- **パスワード再入力**
物品の購入などに先立って、正規利用者であることを再確認する
共有PCで別人が捜査している状況などがなく、本当に正規の利用者であることを確認する
→成りすまし対策や、確認を強く求めるような要件がある画面に効果的である。

- **Refererチェック**
プログラミングによるRefererチェックの例
```Ruby
if (preg_match('/\Ahttp:\/\/example\.jp\/45\/45-002\.php/', @$_SERVER['HTTP_REFERER'] !== 1) {
    die('正規の画面から実行してください');
}
```
→これには色々な制約があるため、この確認方法は社内システムなど利用者の環境を限定する場合で、かつ既存アプリケーションの脆弱性対策の場合に限って利用するとよい。

#### 保険的な対策
「重要な処理」の実行後に、登録済みメールアドレスに通知メールを送信する
